{"cells":[{"source":"<a href=\"https://www.kaggle.com/code/ryancardwell/chronosorcav10?scriptVersionId=271405156\" target=\"_blank\"><img align=\"left\" alt=\"Kaggle\" title=\"Open in Kaggle\" src=\"https://kaggle.com/static/images/open-in-kaggle.svg\"></a>","metadata":{},"cell_type":"markdown"},{"cell_type":"markdown","id":"5f72fe61","metadata":{"papermill":{"duration":0.004544,"end_time":"2025-10-28T00:56:39.239882","exception":false,"start_time":"2025-10-28T00:56:39.235338","status":"completed"},"tags":[]},"source":["# ChronosOrca v3 — Hybrid Neural–Symbolic ARC Solver (Contest-Safe)\n","**Design:** Kaggle-friendly, deterministic seeds, verbose logs, local metrics."]},{"cell_type":"code","execution_count":1,"id":"97433e80","metadata":{"execution":{"iopub.execute_input":"2025-10-28T00:56:39.249976Z","iopub.status.busy":"2025-10-28T00:56:39.249592Z","iopub.status.idle":"2025-10-28T00:56:44.277818Z","shell.execute_reply":"2025-10-28T00:56:44.276849Z"},"papermill":{"duration":5.035258,"end_time":"2025-10-28T00:56:44.279447","exception":false,"start_time":"2025-10-28T00:56:39.244189","status":"completed"},"tags":[]},"outputs":[],"source":["\n","import os, sys, json, time, math, random, logging, itertools, statistics\n","from dataclasses import dataclass, field\n","from typing import List, Dict, Tuple, Optional, Any, Callable\n","from collections import defaultdict, Counter, deque\n","from pathlib import Path\n","import numpy as np\n","\n","try:\n","    import torch\n","    import torch.nn as nn\n","    import torch.nn.functional as F\n","    import torch.optim as optim\n","    TORCH = True\n","except Exception:\n","    TORCH = False\n","\n","try:\n","    from scipy.optimize import linear_sum_assignment\n","    from scipy.ndimage import label\n","    SCIPY = True\n","except Exception:\n","    SCIPY = False\n","\n","logging.basicConfig(level=logging.INFO, format=\"%(asctime)s | %(levelname)5s | %(message)s\")\n","log = logging.getLogger(\"chronosorca\")\n","\n","CONFIG = {\n","    \"SEED\": 1337,\n","    \"TIME_PER_TASK_S\": 10.0,\n","    \"BEAM_WIDTH\": 16,\n","    \"BEAM_DEPTH\": 6,\n","    \"FAMILY_CAPS\": {\"geometric\": 2, \"color\": 3, \"size\": 2, \"object\": 3, \"pattern\": 2},\n","    \"RELAXED_OK\": True,\n","    \"RELAXED_MIN_IOU\": 0.90,\n","    \"BG\": 0,\n","    \"VETO_THRESH\": 0.35,\n","    \"VETO_FEATS\": 32,\n","    \"VETO_HIDDEN\": 64,\n","    \"TTT_STEPS\": 12,\n","    \"TTT_LR\": 1e-3,\n","    \"MAX_PERIOD\": 12,\n","    \"MAX_GRID_SIDE\": 60,\n","    \"ATTEMPTS_PER_TEST\": 2,\n","    \"PRINT_SAMPLE_GRIDS\": False,\n","    \"METRIC_FLUSH_EVERY\": 1,\n","}\n","\n","random.seed(CONFIG[\"SEED\"])\n","np.random.seed(CONFIG[\"SEED\"])\n","if TORCH:\n","    torch.manual_seed(CONFIG[\"SEED\"])\n","\n","class MetricLog:\n","    def __init__(self):\n","        self.rows = []\n","        self.start = time.time()\n","    def log(self, **kwargs):\n","        row = {\"t\": round(time.time() - self.start, 3)}\n","        row.update(kwargs)\n","        self.rows.append(row)\n","        msg = \" | \".join(f\"{k}={v}\" for k,v in row.items())\n","        log.info(f\"[metrics] {msg}\")\n","    def summary(self):\n","        agg = defaultdict(list)\n","        for r in self.rows:\n","            for k,v in r.items():\n","                if k == \"t\": continue\n","                try:\n","                    agg[k].append(float(v))\n","                except:\n","                    pass\n","        return {k: round(sum(v)/max(1,len(v)),4) for k,v in agg.items()}\n","\n","METRICS = MetricLog()\n","\n","def grid_to_np(g):\n","    if not g or not isinstance(g[0], list): return np.zeros((1,1), dtype=np.uint8)\n","    arr = np.array(g, dtype=np.uint8)\n","    arr[arr>9]=9; arr[arr<0]=0\n","    return arr\n","\n","def np_to_grid(a):\n","    a = np.asarray(a, dtype=np.int16)\n","    a[a>9]=9; a[a<0]=0\n","    return a.astype(int).tolist()\n","\n","def same_shape(a,b):\n","    return a.shape == b.shape\n","\n","def safe_iou(a,b):\n","    if not same_shape(a,b): return 0.0\n","    return float((a==b).sum())/max(1,a.size)\n","\n","def palette(g):\n","    return sorted(list(np.unique(g)))\n"]},{"cell_type":"code","execution_count":2,"id":"35b11c04","metadata":{"execution":{"iopub.execute_input":"2025-10-28T00:56:44.28895Z","iopub.status.busy":"2025-10-28T00:56:44.28853Z","iopub.status.idle":"2025-10-28T00:56:44.302857Z","shell.execute_reply":"2025-10-28T00:56:44.302029Z"},"papermill":{"duration":0.020789,"end_time":"2025-10-28T00:56:44.304325","exception":false,"start_time":"2025-10-28T00:56:44.283536","status":"completed"},"tags":[]},"outputs":[],"source":["# === HOTFIX: robust grid <-> numpy, safe train/test parsing, and minor guards ===\n","import numpy as np\n","\n","def grid_to_np(g):\n","    \"\"\"Robustly convert ARC grid (list[list[int]] or np.ndarray) -> np.uint8 2D array in [0..9].\"\"\"\n","    if isinstance(g, np.ndarray):\n","        arr = g\n","    elif isinstance(g, list):\n","        # Handle empty or ragged lists\n","        if len(g) == 0 or not isinstance(g[0], list):\n","            return np.zeros((1, 1), dtype=np.uint8)\n","        arr = np.array(g, dtype=np.int32)\n","    else:\n","        return np.zeros((1, 1), dtype=np.uint8)\n","\n","    # Force 2D\n","    if arr.ndim == 0:\n","        arr = np.zeros((1, 1), dtype=np.int32)\n","    elif arr.ndim == 1:\n","        side = int(np.ceil(np.sqrt(arr.size))) or 1\n","        pad = side * side - arr.size\n","        if pad > 0:\n","            arr = np.pad(arr, (0, pad), constant_values=0)\n","        arr = arr.reshape(side, side)\n","    elif arr.ndim > 2:\n","        arr = arr.squeeze()\n","        if arr.ndim != 2:\n","            # Fall back to 1x1 if still not 2D\n","            arr = np.array([[int(arr.flat[0]) if arr.size else 0]])\n","\n","    # Clamp and cast\n","    arr = np.clip(arr, 0, 9).astype(np.uint8)\n","    return arr\n","\n","def numpy_to_grid(arr):\n","    \"\"\"np.ndarray (any dtype/shape) -> list[list[int]] clamped to [0..9], 2D.\"\"\"\n","    a = grid_to_np(arr)  # re-use robustness\n","    return a.tolist()\n","\n","def safe_get_train(task):\n","    \"\"\"Return normalized train pairs with 'input','output' as 2D np.uint8.\"\"\"\n","    out = []\n","    for p in task.get(\"train\", []):\n","        # Some datasets store np arrays already\n","        g_in = grid_to_np(p.get(\"input\", []))\n","        g_out = grid_to_np(p.get(\"output\", []))\n","        out.append({\"input\": g_in, \"output\": g_out})\n","    return out\n","\n","def safe_get_test_input(task, k=0):\n","    \"\"\"Return kth test input as 2D np.uint8.\"\"\"\n","    ti = task.get(\"test\", [])\n","    if not ti:\n","        return np.zeros((1, 1), dtype=np.uint8)\n","    return grid_to_np(ti[k].get(\"input\", []))\n","\n","# ---- Small safety shims for downstream code that called old helpers ----\n","# If your code used grid_size(grid_as_list), it will still work via grid_to_np.\n","def grid_size(g):\n","    a = grid_to_np(g)\n","    return int(a.shape[0]), int(a.shape[1])\n","\n","# === PATCH CALL SITES (minimal): replace in your code ===\n","# OLD:\n","# train = [{\"input\":grid_to_np(p[\"input\"]), \"output\":grid_to_np(p[\"output\"])} for p in task.get(\"train\",[])]\n","# test_in = grid_to_np(task[\"test\"][0][\"input\"])\n","# NEW:\n","# train = safe_get_train(task)\n","# test_in = safe_get_test_input(task, 0)\n","\n","# Optional: quick self-test to ensure ambiguity error is gone\n","_g_examples = [[], [[1,2],[3,4]], np.array([[5,6],[7,8]], dtype=np.int32)]\n","for _g in _g_examples:\n","    _a = grid_to_np(_g)\n","    assert _a.ndim == 2 and _a.dtype == np.uint8\n"]},{"cell_type":"code","execution_count":3,"id":"6dc32159","metadata":{"execution":{"iopub.execute_input":"2025-10-28T00:56:44.312961Z","iopub.status.busy":"2025-10-28T00:56:44.312644Z","iopub.status.idle":"2025-10-28T00:56:44.321777Z","shell.execute_reply":"2025-10-28T00:56:44.320787Z"},"papermill":{"duration":0.01507,"end_time":"2025-10-28T00:56:44.323163","exception":false,"start_time":"2025-10-28T00:56:44.308093","status":"completed"},"tags":[]},"outputs":[],"source":["\n","def discover_period(g, axis=1, max_p=None):\n","    H, W = g.shape\n","    max_p = max_p or CONFIG[\"MAX_PERIOD\"]\n","    if axis == 1:\n","        for p in range(1, min(W, max_p)+1):\n","            if np.all(g == np.tile(g[:, :p], (1, W//p + 1))[:, :W]):\n","                return p\n","    else:\n","        for p in range(1, min(H, max_p)+1):\n","            if np.all(g == np.tile(g[:p, :], (H//p + 1, 1))[:H, :]):\n","                return p\n","    return None\n","\n","def detect_stripes(g):\n","    h, w = g.shape\n","    horiz = discover_period(g, axis=1)\n","    vert  = discover_period(g, axis=0)\n","    return {\n","        \"h_period\": horiz or 0,\n","        \"v_period\": vert or 0,\n","        \"is_hstripe\": bool(horiz and h>=horiz and w%horiz==0),\n","        \"is_vstripe\": bool(vert and w>=vert and h%vert==0),\n","    }\n","\n","def ccl_components(g, bg=None):\n","    if not SCIPY:\n","        return []\n","    bg = CONFIG[\"BG\"] if bg is None else bg\n","    comps = []\n","    for c in range(10):\n","        if c == bg: continue\n","        mask = (g == c)\n","        if not mask.any(): continue\n","        lab, n = label(mask)\n","        for fid in range(1, n+1):\n","            m = (lab == fid)\n","            if m.sum() > 0:\n","                comps.append((m, c))\n","    return comps\n"]},{"cell_type":"code","execution_count":4,"id":"5ddc78cf","metadata":{"execution":{"iopub.execute_input":"2025-10-28T00:56:44.332097Z","iopub.status.busy":"2025-10-28T00:56:44.331775Z","iopub.status.idle":"2025-10-28T00:56:44.36015Z","shell.execute_reply":"2025-10-28T00:56:44.359125Z"},"papermill":{"duration":0.034957,"end_time":"2025-10-28T00:56:44.361859","exception":false,"start_time":"2025-10-28T00:56:44.326902","status":"completed"},"tags":[]},"outputs":[],"source":["\n","class DSL:\n","    @staticmethod\n","    def identity(g): return g.copy()\n","    @staticmethod\n","    def rotate_90(g):  return np.rot90(g, 1)\n","    @staticmethod\n","    def rotate_180(g): return np.rot90(g, 2)\n","    @staticmethod\n","    def rotate_270(g): return np.rot90(g, 3)\n","    @staticmethod\n","    def flip_h(g): return np.fliplr(g)\n","    @staticmethod\n","    def flip_v(g): return np.flipud(g)\n","    @staticmethod\n","    def transpose(g): return g.T\n","    @staticmethod\n","    def shift_left(g):  return np.roll(g, -1, axis=1)\n","    @staticmethod\n","    def shift_right(g): return np.roll(g,  1, axis=1)\n","    @staticmethod\n","    def shift_up(g):    return np.roll(g, -1, axis=0)\n","    @staticmethod\n","    def shift_down(g):  return np.roll(g,  1, axis=0)\n","\n","    @staticmethod\n","    def invert_colors(g):\n","        r = g.copy()\n","        r = np.where(r!=0, 10 - r, r)\n","        return r\n","\n","    @staticmethod\n","    def replace_color(g, old, new):\n","        r = g.copy(); r[g==old] = new; return r\n","\n","    @staticmethod\n","    def recolor_with_palette_bijection(g, ref):\n","        if not SCIPY: return g.copy()\n","        colors_in  = np.unique(g)\n","        colors_ref = np.unique(ref)\n","        cost = np.zeros((len(colors_in), len(colors_ref)))\n","        for i, ci in enumerate(colors_in):\n","            for j, cj in enumerate(colors_ref):\n","                overlap = np.sum((g==ci) & (ref==cj))\n","                cost[i, j] = -overlap\n","        ri, cj = linear_sum_assignment(cost)\n","        mapping = {int(colors_in[i]): int(colors_ref[j]) for i,j in zip(ri, cj)}\n","        out = g.copy()\n","        for cin, cout in mapping.items():\n","            out[g==cin] = cout\n","        for cin in set(colors_in)-set(mapping.keys()):\n","            out[g==cin] = CONFIG[\"BG\"]\n","        return out\n","\n","    @staticmethod\n","    def scale_2x(g): return np.repeat(np.repeat(g,2,axis=0),2,axis=1)\n","    @staticmethod\n","    def scale_3x(g): return np.repeat(np.repeat(g,3,axis=0),3,axis=1)\n","    @staticmethod\n","    def crop_to_content(g, bg=None):\n","        bg = CONFIG[\"BG\"] if bg is None else bg\n","        mask = (g != bg)\n","        if not mask.any(): return g.copy()\n","        rows = np.any(mask, axis=1)\n","        cols = np.any(mask, axis=0)\n","        return g[rows][:, cols]\n","    @staticmethod\n","    def add_border(g, b=1, color=1):\n","        h,w = g.shape\n","        r = np.full((h+2*b, w+2*b), color, dtype=g.dtype)\n","        r[b:h+b, b:w+b] = g\n","        return r\n","\n","    @staticmethod\n","    def extract_largest_object(g, bg=None):\n","        bg = CONFIG[\"BG\"] if bg is None else bg\n","        comps = ccl_components(g, bg)\n","        if not comps: return g.copy()\n","        largest = max(comps, key=lambda x: x[0].sum())\n","        r = np.full_like(g, bg)\n","        r[largest[0]] = largest[1]\n","        return r\n","\n","    @staticmethod\n","    def separate_objects_by_color(g, bg=None):\n","        bg = CONFIG[\"BG\"] if bg is None else bg\n","        comps = ccl_components(g, bg)\n","        r = np.full_like(g, bg)\n","        for i,(m,c) in enumerate(comps):\n","            r[m] = (i+1) % 10\n","        return r\n","\n","    @staticmethod\n","    def align_objects_grid(g, grid_size=3, bg=None):\n","        bg = CONFIG[\"BG\"] if bg is None else bg\n","        comps = ccl_components(g, bg)\n","        if not comps: return g.copy()\n","        objs = []\n","        for m,c in comps:\n","            rs, cs = np.where(m)\n","            if len(rs)==0: continue\n","            objs.append((rs.min(), cs.min(), rs.max(), cs.max(), c, m))\n","        objs.sort(key=lambda x:(x[0],x[1]))\n","        h,w = g.shape; cell_h=h//grid_size; cell_w=w//grid_size\n","        r = np.full_like(g, bg)\n","        for i,(r0,c0,r1,c1,c,m) in enumerate(objs[:grid_size*grid_size]):\n","            if cell_h==0 or cell_w==0: break\n","            oh, ow = r1-r0+1, c1-c0+1\n","            gr, gc = i//grid_size, i%grid_size\n","            sr = gr*cell_h + max(0,(cell_h-oh)//2)\n","            sc = gc*cell_w + max(0,(cell_w-ow)//2)\n","            oh2 = min(oh, r.shape[0]-sr); ow2 = min(ow, r.shape[1]-sc)\n","            if oh2<=0 or ow2<=0: continue\n","            sub = m[r0:r0+oh2, c0:c0+ow2]\n","            r[sr:sr+oh2, sc:sc+ow2][sub] = c\n","        return r\n","\n","    @staticmethod\n","    def tile_to(g, h, w):\n","        gh, gw = g.shape\n","        if gh==0 or gw==0: return g.copy()\n","        t = np.tile(g, (math.ceil(h/gh), math.ceil(w/gw)))\n","        return t[:h,:w]\n","\n","def build_primitive_families(train_pairs):\n","    fam = {\n","        \"geometric\": {\n","            \"identity\": DSL.identity, \"rotate_90\": DSL.rotate_90, \"rotate_180\": DSL.rotate_180, \"rotate_270\": DSL.rotate_270,\n","            \"flip_h\": DSL.flip_h, \"flip_v\": DSL.flip_v, \"transpose\": DSL.transpose,\n","            \"shift_left\": DSL.shift_left, \"shift_right\": DSL.shift_right, \"shift_up\": DSL.shift_up, \"shift_down\": DSL.shift_down,\n","        },\n","        \"color\": {\n","            \"invert\": DSL.invert_colors,\n","            \"recolor_bijection\": (lambda g, ref=train_pairs[0][\"output\"]: DSL.recolor_with_palette_bijection(g, ref) if isinstance(ref,np.ndarray) else g),\n","        },\n","        \"size\": {\n","            \"scale_2x\": DSL.scale_2x, \"scale_3x\": DSL.scale_3x, \"crop_to_content\": DSL.crop_to_content, \"add_border\": DSL.add_border,\n","        },\n","        \"object\": {\n","            \"extract_largest\": DSL.extract_largest_object, \"separate_by_color\": DSL.separate_objects_by_color, \"align_grid\": DSL.align_objects_grid,\n","        },\n","        \"pattern\": {\n","            \"tile_to_ref\": (lambda g, ref=train_pairs[0][\"output\"]: DSL.tile_to(g, ref.shape[0], ref.shape[1]) if isinstance(ref,np.ndarray) else g)\n","        }\n","    }\n","    colors = set()\n","    for p in train_pairs:\n","        colors |= set(np.unique(p[\"input\"])); colors |= set(np.unique(p[\"output\"]))\n","    colors = sorted(list(colors))[:8]\n","    for a in colors:\n","        for b in colors:\n","            if a==b: continue\n","            name = f\"replace_{a}_to_{b}\"\n","            fam[\"color\"][name] = (lambda g, aa=a, bb=b: DSL.replace_color(g, aa, bb))\n","    return fam\n"]},{"cell_type":"code","execution_count":5,"id":"e47c0cb5","metadata":{"execution":{"iopub.execute_input":"2025-10-28T00:56:44.370765Z","iopub.status.busy":"2025-10-28T00:56:44.370367Z","iopub.status.idle":"2025-10-28T00:56:44.381185Z","shell.execute_reply":"2025-10-28T00:56:44.380175Z"},"papermill":{"duration":0.017006,"end_time":"2025-10-28T00:56:44.382773","exception":false,"start_time":"2025-10-28T00:56:44.365767","status":"completed"},"tags":[]},"outputs":[],"source":["\n","def induce_size_rule(train_pairs):\n","    dims_in  = [p[\"input\"].shape for p in train_pairs]\n","    dims_out = [p[\"output\"].shape for p in train_pairs]\n","    rh = []; rw = []; dh = []; dw = []\n","    for di,do in zip(dims_in,dims_out):\n","        if di[0]>0 and di[1]>0:\n","            if do[0]%di[0]==0: rh.append(do[0]//di[0])\n","            if do[1]%di[1]==0: rw.append(do[1]//di[1])\n","        dh.append(do[0]-di[0]); dw.append(do[1]-di[1])\n","    if rh and rw and len(set(rh))==1 and len(set(rw))==1:\n","        return {\"type\":\"ratio\",\"h\":rh[0],\"w\":rw[0]}\n","    if dh and dw and len(set(dh))==1 and len(set(dw))==1:\n","        return {\"type\":\"delta\",\"h\":dh[0],\"w\":dw[0]}\n","    return None\n","\n","def try_fast_bijection_symmetry(train_pairs, test_input):\n","    SYMS = [lambda x:x, DSL.rotate_90, DSL.rotate_180, DSL.rotate_270, DSL.flip_h, DSL.flip_v, DSL.transpose]\n","    for s in SYMS:\n","        ok=True; mapping=None\n","        for pair in train_pairs:\n","            A = s(pair[\"input\"]); B = pair[\"output\"]\n","            if A.shape!=B.shape: ok=False; break\n","            m = {}\n","            for a,b in zip(A.flatten(), B.flatten()):\n","                if a in m and m[a]!=b: ok=False; break\n","                m[a]=b\n","            if not ok: break\n","            if mapping is None: mapping = m\n","            elif mapping != m: ok=False; break\n","        if ok and mapping is not None:\n","            T = s(test_input)\n","            R = T.copy()\n","            for a,b in mapping.items():\n","                R[T==a]=b\n","            return R\n","    return None\n"]},{"cell_type":"code","execution_count":6,"id":"ce2b8e87","metadata":{"execution":{"iopub.execute_input":"2025-10-28T00:56:44.391451Z","iopub.status.busy":"2025-10-28T00:56:44.391058Z","iopub.status.idle":"2025-10-28T00:56:44.409928Z","shell.execute_reply":"2025-10-28T00:56:44.409123Z"},"papermill":{"duration":0.024824,"end_time":"2025-10-28T00:56:44.411357","exception":false,"start_time":"2025-10-28T00:56:44.386533","status":"completed"},"tags":[]},"outputs":[],"source":["\n","class TinyVetoNet(nn.Module if TORCH else object):\n","    def __init__(self, input_dim=32, hidden=64):\n","        if TORCH:\n","            super().__init__()\n","            self.net = nn.Sequential(\n","                nn.Linear(input_dim, hidden), nn.ReLU(),\n","                nn.Linear(hidden, hidden), nn.ReLU(),\n","                nn.Linear(hidden, 1), nn.Sigmoid()\n","            )\n","        else:\n","            pass\n","    def forward(self, x):\n","        if TORCH: return self.net(x)\n","        return 0.5\n","\n","def veto_features(g_pred, g_in, g_ref):\n","    H,W = g_pred.shape\n","    pal_pred = len(np.unique(g_pred))\n","    pal_in   = len(np.unique(g_in))\n","    size_ok = 1.0 if (g_ref is not None and g_pred.shape==g_ref.shape) else 0.0\n","    bg_pred = float((g_pred==CONFIG[\"BG\"]).mean())\n","    bg_in   = float((g_in  ==CONFIG[\"BG\"]).mean())\n","    iou = float((g_pred==g_ref).mean()) if (g_ref is not None and g_pred.shape==g_ref.shape) else 0.0\n","    d = detect_stripes(g_pred)\n","    feats = np.array([H,W,pal_pred,pal_in,size_ok,bg_pred,bg_in,iou,\n","                      d[\"h_period\"], d[\"v_period\"], int(d[\"is_hstripe\"]), int(d[\"is_vstripe\"])], dtype=np.float32)\n","    if feats.size < CONFIG[\"VETO_FEATS\"]:\n","        feats = np.pad(feats, (0, CONFIG[\"VETO_FEATS\"]-feats.size))\n","    else:\n","        feats = feats[:CONFIG[\"VETO_FEATS\"]]\n","    return feats.astype(np.float32)\n","\n","@dataclass\n","class Node:\n","    grid: np.ndarray\n","    program: List[Tuple[str,str]] = field(default_factory=list)\n","    fam_counts: Dict[str,int] = field(default_factory=lambda: defaultdict(int))\n","    score: float = 0.0\n","\n","def fit_score(pred, target):\n","    if pred.shape!=target.shape: return 0.0\n","    acc = (pred==target).mean()\n","    ha = Counter(pred.flatten()); hb = Counter(target.flatten())\n","    inter = sum(min(ha[k], hb[k]) for k in set(ha)|set(hb))\n","    hist = inter / max(1, pred.size, target.size)\n","    return 0.75*acc + 0.25*hist\n","\n","def beam_search(task, veto_model):\n","    train = [{\"input\":grid_to_np(p[\"input\"]), \"output\":grid_to_np(p[\"output\"])} for p in task[\"train\"]]\n","    test_in = grid_to_np(task[\"test\"][0][\"input\"])\n","    fams = build_primitive_families(train)\n","    veto_ref = train[0][\"output\"] if train else None\n","\n","    start = try_fast_bijection_symmetry(train, test_in)\n","    beam = [Node(start if start is not None else test_in)]\n","    best = (None, 0.0, [])\n","\n","    t0 = time.time()\n","    for depth in range(CONFIG[\"BEAM_DEPTH\"]):\n","        if time.time()-t0 > CONFIG[\"TIME_PER_TASK_S\"]*0.8:\n","            log.warning(\"Beam budget nearing; breaking.\")\n","            break\n","\n","        cand = []\n","        for node in beam:\n","            for fam, ops in fams.items():\n","                if node.fam_counts.get(fam,0) >= CONFIG[\"FAMILY_CAPS\"].get(fam,1):\n","                    continue\n","                for opname, op in ops.items():\n","                    try:\n","                        g2 = op(node.grid)\n","                        vscore = 1.0\n","                        if veto_model is not None and TORCH:\n","                            feats = veto_features(g2, test_in, veto_ref)\n","                            with torch.no_grad():\n","                                vscore = float(veto_model(torch.tensor(feats).unsqueeze(0)).item())\n","                        if vscore < CONFIG[\"VETO_THRESH\"]:\n","                            continue\n","                        scs = [fit_score(g2, p[\"output\"]) for p in train] if train else [0.5]\n","                        sc = min(scs) if CONFIG[\"RELAXED_OK\"] else (1.0 if all(s==1.0 for s in scs) else 0.0)\n","                        new = Node(g2, node.program+[(fam,opname)], dict(node.fam_counts))\n","                        new.fam_counts[fam] = new.fam_counts.get(fam,0)+1\n","                        new.score = sc\n","                        cand.append(new)\n","                        if sc > best[1]:\n","                            best = (g2, sc, new.program)\n","                    except Exception:\n","                        continue\n","        cand.sort(key=lambda n: n.score, reverse=True)\n","        beam = cand[:CONFIG[\"BEAM_WIDTH\"]]\n","        if best[1] >= 0.999:\n","            break\n","\n","    return best\n"]},{"cell_type":"code","execution_count":7,"id":"4146d32e","metadata":{"execution":{"iopub.execute_input":"2025-10-28T00:56:44.420328Z","iopub.status.busy":"2025-10-28T00:56:44.419774Z","iopub.status.idle":"2025-10-28T00:56:44.431024Z","shell.execute_reply":"2025-10-28T00:56:44.430202Z"},"papermill":{"duration":0.017316,"end_time":"2025-10-28T00:56:44.432446","exception":false,"start_time":"2025-10-28T00:56:44.41513","status":"completed"},"tags":[]},"outputs":[],"source":["\n","class TinyPolicy(nn.Module if TORCH else object):\n","    def __init__(self, action_dim):\n","        if TORCH:\n","            super().__init__()\n","            self.enc = nn.Sequential(\n","                nn.Conv2d(1,16,3,padding=1), nn.ReLU(),\n","                nn.Conv2d(16,32,3,padding=1), nn.ReLU(),\n","                nn.AdaptiveAvgPool2d((6,6)),\n","            )\n","            self.head = nn.Sequential(\n","                nn.Flatten(),\n","                nn.Linear(32*6*6, 128), nn.ReLU(),\n","                nn.Linear(128, action_dim)\n","            )\n","        else:\n","            pass\n","    def forward(self, x):\n","        if TORCH:\n","            return self.head(self.enc(x))\n","        return 0.0\n","\n","def neural_policy_suggest(train_pairs, fams, steps=12):\n","    actions = [(fam,op) for fam in fams for op in fams[fam].keys()]\n","    if not TORCH:\n","        random.shuffle(actions); \n","        return actions[:min(10,len(actions))]\n","    net = TinyPolicy(action_dim=len(actions))\n","    opt = optim.Adam(net.parameters(), lr=CONFIG[\"TTT_LR\"])\n","    losses = []\n","    for _ in range(steps):\n","        if not train_pairs: break\n","        p = random.choice(train_pairs)\n","        x = torch.tensor(p[\"input\"][None,None,:,:], dtype=torch.float32)\n","        y = torch.tensor(p[\"output\"][None,None,:,:], dtype=torch.float32)\n","        feat_x = net.enc(x); feat_y = net.enc(y)\n","        loss = 1.0 - F.cosine_similarity(feat_x.flatten(1), feat_y.flatten(1)).mean()\n","        opt.zero_grad(); loss.backward(); opt.step()\n","        losses.append(float(loss.item()))\n","    if losses:\n","        from statistics import mean\n","        METRICS.log(policy_ttt_loss=mean(losses))\n","    if train_pairs:\n","        x = torch.tensor(train_pairs[-1][\"input\"][None,None,:,:], dtype=torch.float32)\n","        with torch.no_grad():\n","            logits = net(x).flatten().cpu().numpy()\n","        order = np.argsort(-logits)\n","    else:\n","        order = np.arange(len(actions))\n","    ranked = [actions[i] for i in order[:min(20, len(actions))]]\n","    return ranked\n"]},{"cell_type":"code","execution_count":8,"id":"bb2c5057","metadata":{"execution":{"iopub.execute_input":"2025-10-28T00:56:44.441076Z","iopub.status.busy":"2025-10-28T00:56:44.440772Z","iopub.status.idle":"2025-10-28T00:56:44.45356Z","shell.execute_reply":"2025-10-28T00:56:44.452546Z"},"papermill":{"duration":0.01914,"end_time":"2025-10-28T00:56:44.455339","exception":false,"start_time":"2025-10-28T00:56:44.436199","status":"completed"},"tags":[]},"outputs":[],"source":["\n","def solve_one_task(task, veto_model):\n","    t0 = time.time()\n","    train = safe_get_train(task)\n","    test_in = safe_get_test_input(task, 0)\n","\n","    size_rule = induce_size_rule(train) if train else None\n","    if size_rule and size_rule[\"type\"]==\"ratio\":\n","        H = test_in.shape[0]*size_rule[\"h\"]; W = test_in.shape[1]*size_rule[\"w\"]\n","        fast = DSL.tile_to(test_in, H, W)\n","        METRICS.log(fast_path=\"size_ratio\", h=size_rule[\"h\"], w=size_rule[\"w\"])\n","        return {\"attempt_1\": np_to_grid(fast), \"attempt_2\": np_to_grid(fast), \"confidence\": 1.0, \"source\":\"fast_ratio\"}\n","\n","    g_sym, c_sym, prog = beam_search(task, veto_model)\n","    METRICS.log(stage=\"symbolic\", conf=round(c_sym,4), prog_len=(len(prog) if prog else 0))\n","\n","    if g_sym is not None and c_sym >= 0.99:\n","        return {\"attempt_1\": np_to_grid(g_sym), \"attempt_2\": np_to_grid(g_sym), \"confidence\": float(c_sym), \"source\": \"symbolic_exact\"}\n","\n","    fams = build_primitive_families(train)\n","    suggestions = neural_policy_suggest(train, fams, steps=CONFIG[\"TTT_STEPS\"])\n","    node = Node(test_in); best = (g_sym, c_sym, prog if prog else [])\n","    for (fam,opname) in suggestions[:10]:\n","        try:\n","            g2 = fams[fam][opname](node.grid)\n","            scs = [fit_score(g2, p[\"output\"]) for p in train] if train else [0.5]\n","            sc = min(scs) if CONFIG[\"RELAXED_OK\"] else (1.0 if all(s==1.0 for s in scs) else 0.0)\n","            if sc > best[1]:\n","                best = (g2, sc, [(fam,opname)])\n","        except:\n","            pass\n","\n","    g_best, c_best, prog_best = best\n","    src = \"neural_guided\" if prog_best and prog_best!=prog else \"symbolic_loose\"\n","    if g_best is None:\n","        g_best = test_in.copy(); c_best = 0.5; src=\"fallback_identity\"\n","    alt = DSL.align_objects_grid(g_best) if SCIPY else g_best\n","    return {\"attempt_1\": np_to_grid(g_best), \"attempt_2\": np_to_grid(alt), \"confidence\": float(c_best), \"source\": src}\n","\n","def chronos_orca_run(TEST, task_ids):\n","    veto = TinyVetoNet(32, 64) if TORCH else None\n","    out = {}\n","    for i, tid in enumerate(task_ids):\n","        log.info(f\"=== Task {i+1}/{len(task_ids)}: {tid} ===\")\n","        res = solve_one_task(TEST[tid], veto)\n","        out[tid] = [{\"attempt_1\": res[\"attempt_1\"], \"attempt_2\": res[\"attempt_2\"]}]\n","        METRICS.log(task=tid, conf=res[\"confidence\"], source=res[\"source\"])\n","    return out\n"]},{"cell_type":"code","execution_count":9,"id":"f69b543b","metadata":{"execution":{"iopub.execute_input":"2025-10-28T00:56:44.464047Z","iopub.status.busy":"2025-10-28T00:56:44.463395Z","iopub.status.idle":"2025-10-28T00:56:44.471012Z","shell.execute_reply":"2025-10-28T00:56:44.470229Z"},"papermill":{"duration":0.013368,"end_time":"2025-10-28T00:56:44.472373","exception":false,"start_time":"2025-10-28T00:56:44.459005","status":"completed"},"tags":[]},"outputs":[],"source":["\n","def find_arc_paths():\n","    cands = [\"/kaggle/input/arc-prize-2025\",\"/kaggle/input/arc-agi\",\"/kaggle/input/arc-prize-2024\",\".\"]\n","    files = {\"test_ch\": [\"arc-agi_test_challenges.json\",\"test.json\",\"arc_test.json\"]}\n","    out = {}\n","    for key, names in files.items():\n","        for d in cands:\n","            for nm in names:\n","                p = Path(d)/nm\n","                if p.exists():\n","                    out[key] = str(p); break\n","            if key in out: break\n","    return out\n","\n","def load_TEST(path):\n","    with open(path,\"r\") as f:\n","        data = json.load(f)\n","    for k,task in data.items():\n","        for pair in task.get(\"train\",[]):\n","            pair[\"input\"]  = np.array(pair[\"input\"], dtype=np.uint8)\n","            pair[\"output\"] = np.array(pair[\"output\"], dtype=np.uint8)\n","        for pair in task.get(\"test\",[]):\n","            pair[\"input\"]  = np.array(pair[\"input\"], dtype=np.uint8)\n","    return data, list(data.keys())\n","\n","def write_submission(sub, path=\"submission.json\"):\n","    with open(path,\"w\") as f:\n","        json.dump(sub, f)\n","    log.info(f\"Saved submission to {path} ({os.path.getsize(path)} bytes)\")\n"]},{"cell_type":"code","execution_count":10,"id":"041f680c","metadata":{"execution":{"iopub.execute_input":"2025-10-28T00:56:44.48133Z","iopub.status.busy":"2025-10-28T00:56:44.48055Z","iopub.status.idle":"2025-10-28T00:59:02.041522Z","shell.execute_reply":"2025-10-28T00:59:02.040071Z"},"papermill":{"duration":137.567495,"end_time":"2025-10-28T00:59:02.043617","exception":false,"start_time":"2025-10-28T00:56:44.476122","status":"completed"},"tags":[]},"outputs":[],"source":["\n","if __name__ == \"__main__\":\n","    paths = find_arc_paths()\n","    if \"test_ch\" not in paths:\n","        log.error(\"Test challenge JSON not found. Place ARC dataset in /kaggle/input.\")\n","    else:\n","        TEST, ids = load_TEST(paths[\"test_ch\"])\n","        log.info(f\"Loaded {len(ids)} test tasks from {paths['test_ch']}\")\n","        submission = chronos_orca_run(TEST, ids)\n","        write_submission(submission, \"submission.json\")\n","        log.info(\"Metrics summary: %s\", METRICS.summary())\n"]},{"cell_type":"markdown","id":"eddc1750","metadata":{"papermill":{"duration":0.003544,"end_time":"2025-10-28T00:59:02.051442","exception":false,"start_time":"2025-10-28T00:59:02.047898","status":"completed"},"tags":[]},"source":["\n","## Knobs & Dials\n","- `TIME_PER_TASK_S`, `BEAM_WIDTH`, `BEAM_DEPTH`, `FAMILY_CAPS` — search controls\n","- `RELAXED_OK`, `RELAXED_MIN_IOU` — relaxed fit mode\n","- `VETO_THRESH`, `VETO_FEATS`, `VETO_HIDDEN` — veto net behavior\n","- `TTT_STEPS`, `TTT_LR` — tiny policy adaptation\n","\n","## Design Notes\n","- Contest-safe: no I/O beyond dataset and submission.json; no network.\n","- Verbose logs: per-task metrics line, final summary.\n","- Extensible: add more DSL ops or a bigger policy net within resource limits.\n"]},{"cell_type":"markdown","id":"a999a69a","metadata":{"papermill":{"duration":0.003515,"end_time":"2025-10-28T00:59:02.058799","exception":false,"start_time":"2025-10-28T00:59:02.055284","status":"completed"},"tags":[]},"source":["\n","## Diagnostics & Self-Check\n","The following utilities help validate solver components offline:\n","\n","- **Palette bijection property tests**  \n","- **CCL invariants**: area conservation for masks  \n","- **Stripe detector sanity checks**  \n","- **Beam search smoke tests**  \n","- **Neural policy shape checks**  \n"]},{"cell_type":"code","execution_count":11,"id":"8376d6d3","metadata":{"execution":{"iopub.execute_input":"2025-10-28T00:59:02.067795Z","iopub.status.busy":"2025-10-28T00:59:02.067305Z","iopub.status.idle":"2025-10-28T00:59:02.07818Z","shell.execute_reply":"2025-10-28T00:59:02.076996Z"},"papermill":{"duration":0.017412,"end_time":"2025-10-28T00:59:02.079917","exception":false,"start_time":"2025-10-28T00:59:02.062505","status":"completed"},"tags":[]},"outputs":[],"source":["\n","# Self-checks (non-exhaustive). Safe to run locally.\n","\n","def _test_palette_bijection():\n","    a = np.array([[1,2],[3,4]])\n","    b = np.array([[4,3],[2,1]])\n","    out = DSL.recolor_with_palette_bijection(a,b) if 'linear_sum_assignment' in globals() else a\n","    assert out.shape == a.shape\n","\n","def _test_ccl_invariants():\n","    g = np.array([[0,1,1,0],[0,1,0,2],[0,0,2,2]])\n","    comps = ccl_components(g)\n","    total = 0\n","    for m,c in comps:\n","        total += int(m.sum())\n","    assert total == int((g!=0).sum())\n","\n","def _test_stripes():\n","    g = np.array([[1,2,1,2],[1,2,1,2]])\n","    d = detect_stripes(g)\n","    assert d[\"h_period\"] in (0,2,4)\n","\n","def _test_beam_smoke():\n","    task = {\n","        \"train\":[{\"input\": [[1,1],[2,2]], \"output\": [[2,2],[1,1]]}],\n","        \"test\":[{\"input\": [[3,3],[4,4]]}]\n","    }\n","    task[\"train\"][0][\"input\"] = np.array(task[\"train\"][0][\"input\"],dtype=np.uint8)\n","    task[\"train\"][0][\"output\"] = np.array(task[\"train\"][0][\"output\"],dtype=np.uint8)\n","    task[\"test\"][0][\"input\"] = np.array(task[\"test\"][0][\"input\"],dtype=np.uint8)\n","    g, c, p = beam_search(task, None)\n","    assert isinstance(c, float)\n","\n","def run_self_checks():\n","    _test_palette_bijection()\n","    _test_ccl_invariants()\n","    _test_stripes()\n","    _test_beam_smoke()\n","    print(\"Self-checks passed.\")\n","\n","# Uncomment to run in a local environment (not on ARC eval)\n","# run_self_checks()\n"]},{"cell_type":"markdown","id":"ceed6d86","metadata":{"papermill":{"duration":0.003587,"end_time":"2025-10-28T00:59:02.087351","exception":false,"start_time":"2025-10-28T00:59:02.083764","status":"completed"},"tags":[]},"source":["\n","## Extended Design Rationale\n","\n","### Symbolic First\n","ARC tasks overwhelmingly decompose to short programs over geometry, color, tiling, and object logic.\n","A beam over a broad but **bounded** DSL is the most sample-efficient first strike.\n","\n","### Neural Where It Helps\n","A tiny policy is used only to **rank** candidate operations and provide light **TTT adaptation**\n","to the specifics of a task's palette and motifs (no external data).\n","\n","### Hybrid Verification\n","Whenever possible, we prefer symbolically verifiable solutions (exact program reproducing train pairs),\n","and only accept raw neural predictions when verification fails and confidence is still adequate.\n","\n","### Metrics-First Engineering\n","The engine prints a compact, parseable metrics line per task and an aggregate summary at the end.\n","This keeps iterations fast and scientific without external tooling.\n","\n","### Safe Defaults & Contest Compliance\n","- No internet or external calls.\n","- Exactly two attempts per test grid written in the `submission.json` per ARC rules.\n","- Deterministic seed initialization.\n","\n","### Roadmap Hooks (Commented)\n","- Wider family of DSL ops (morphology, flood-fill edits, symmetry group closures).\n","- Better veto features (entropy, spectrum of Laplacian, object aspect histograms).\n","- Learned priors over program lengths and family orderings.\n"]}],"metadata":{"kaggle":{"accelerator":"none","dataSources":[{"databundleVersionId":11802066,"sourceId":91496,"sourceType":"competition"}],"dockerImageVersionId":31154,"isGpuEnabled":false,"isInternetEnabled":false,"language":"python","sourceType":"notebook"},"kernelspec":{"display_name":"Python 3","language":"python","name":"python3"},"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.11.13"},"papermill":{"default_parameters":{},"duration":149.204236,"end_time":"2025-10-28T00:59:03.815308","environment_variables":{},"exception":null,"input_path":"__notebook__.ipynb","output_path":"__notebook__.ipynb","parameters":{},"start_time":"2025-10-28T00:56:34.611072","version":"2.6.0"}},"nbformat":4,"nbformat_minor":5}