{"cells":[{"source":"<a href=\"https://www.kaggle.com/code/ryancardwell/seawolfprowlert?scriptVersionId=272636446\" target=\"_blank\"><img align=\"left\" alt=\"Kaggle\" title=\"Open in Kaggle\" src=\"https://kaggle.com/static/images/open-in-kaggle.svg\"></a>","metadata":{},"cell_type":"markdown"},{"cell_type":"markdown","id":"142eefc3","metadata":{"papermill":{"duration":0.003704,"end_time":"2025-11-01T14:08:09.316254","exception":false,"start_time":"2025-11-01T14:08:09.31255","status":"completed"},"tags":[]},"source":["# ðŸ† ARC Prize 2025 - Production Solver\n","\n","**Strategy**: 13+ proven transformation patterns  \n","**Target**: 20-40% accuracy on hidden test set  \n","**Approach**: Pattern-based few-shot learning  \n","\n","This solver implements real transformations that work on actual ARC tasks."]},{"cell_type":"code","execution_count":1,"id":"b678e506","metadata":{"execution":{"iopub.execute_input":"2025-11-01T14:08:09.324182Z","iopub.status.busy":"2025-11-01T14:08:09.323791Z","iopub.status.idle":"2025-11-01T14:08:09.334142Z","shell.execute_reply":"2025-11-01T14:08:09.333031Z"},"papermill":{"duration":0.016181,"end_time":"2025-11-01T14:08:09.335955","exception":false,"start_time":"2025-11-01T14:08:09.319774","status":"completed"},"tags":[]},"outputs":[{"name":"stdout","output_type":"stream","text":["âœ… Imports complete\n"]}],"source":["import json\n","import numpy as np\n","from typing import List, Dict, Tuple, Optional, Set\n","from collections import Counter, defaultdict\n","import copy\n","\n","print(\"âœ… Imports complete\")"]},{"cell_type":"markdown","id":"ae365817","metadata":{"papermill":{"duration":0.003079,"end_time":"2025-11-01T14:08:09.342516","exception":false,"start_time":"2025-11-01T14:08:09.339437","status":"completed"},"tags":[]},"source":["## Grid Operations\n","Core primitives for grid manipulation"]},{"cell_type":"code","execution_count":2,"id":"6789deaf","metadata":{"execution":{"iopub.execute_input":"2025-11-01T14:08:09.350354Z","iopub.status.busy":"2025-11-01T14:08:09.350014Z","iopub.status.idle":"2025-11-01T14:08:09.369336Z","shell.execute_reply":"2025-11-01T14:08:09.368269Z"},"papermill":{"duration":0.025464,"end_time":"2025-11-01T14:08:09.371084","exception":false,"start_time":"2025-11-01T14:08:09.34562","status":"completed"},"tags":[]},"outputs":[{"name":"stdout","output_type":"stream","text":["âœ… GridOps defined\n"]}],"source":["Grid = List[List[int]]\n","\n","class GridOps:\n","    \"\"\"Core grid manipulation primitives\"\"\"\n","    \n","    @staticmethod\n","    def to_numpy(grid: Grid) -> np.ndarray:\n","        return np.array(grid, dtype=np.int32)\n","    \n","    @staticmethod\n","    def from_numpy(arr: np.ndarray) -> Grid:\n","        return arr.tolist()\n","    \n","    @staticmethod\n","    def shape(grid: Grid) -> Tuple[int, int]:\n","        if not grid or not grid[0]:\n","            return (0, 0)\n","        return (len(grid), len(grid[0]))\n","    \n","    @staticmethod\n","    def grids_equal(g1: Grid, g2: Grid) -> bool:\n","        if not g1 or not g2:\n","            return g1 == g2\n","        h1, w1 = GridOps.shape(g1)\n","        h2, w2 = GridOps.shape(g2)\n","        if h1 != h2 or w1 != w2:\n","            return False\n","        return all(r1 == r2 for r1, r2 in zip(g1, g2))\n","    \n","    @staticmethod\n","    def rotate_90(grid: Grid, k: int = 1) -> Grid:\n","        arr = GridOps.to_numpy(grid)\n","        return GridOps.from_numpy(np.rot90(arr, -k))\n","    \n","    @staticmethod\n","    def flip_h(grid: Grid) -> Grid:\n","        return [row[::-1] for row in grid]\n","    \n","    @staticmethod\n","    def flip_v(grid: Grid) -> Grid:\n","        return grid[::-1]\n","    \n","    @staticmethod\n","    def transpose(grid: Grid) -> Grid:\n","        if not grid or not grid[0]:\n","            return grid\n","        return list(map(list, zip(*grid)))\n","    \n","    @staticmethod\n","    def get_colors(grid: Grid) -> Set[int]:\n","        return {cell for row in grid for cell in row}\n","    \n","    @staticmethod\n","    def get_background_color(grid: Grid) -> int:\n","        flat = [cell for row in grid for cell in row]\n","        if not flat:\n","            return 0\n","        return Counter(flat).most_common(1)[0][0]\n","    \n","    @staticmethod\n","    def replace_color(grid: Grid, old: int, new: int) -> Grid:\n","        return [[new if cell == old else cell for cell in row] for row in grid]\n","    \n","    @staticmethod\n","    def swap_colors(grid: Grid, c1: int, c2: int) -> Grid:\n","        return [[c2 if cell == c1 else c1 if cell == c2 else cell \n","                 for cell in row] for row in grid]\n","    \n","    @staticmethod\n","    def tile(grid: Grid, rows: int, cols: int) -> Grid:\n","        arr = GridOps.to_numpy(grid)\n","        return GridOps.from_numpy(np.tile(arr, (rows, cols)))\n","    \n","    @staticmethod\n","    def scale_up(grid: Grid, factor: int) -> Grid:\n","        if factor <= 0:\n","            return grid\n","        result = []\n","        for row in grid:\n","            for _ in range(factor):\n","                scaled_row = []\n","                for cell in row:\n","                    scaled_row.extend([cell] * factor)\n","                result.append(scaled_row)\n","        return result\n","    \n","    @staticmethod\n","    def empty_grid(height: int, width: int, fill: int = 0) -> Grid:\n","        return [[fill] * width for _ in range(height)]\n","\n","print(\"âœ… GridOps defined\")"]},{"cell_type":"markdown","id":"899d5723","metadata":{"papermill":{"duration":0.003603,"end_time":"2025-11-01T14:08:09.378011","exception":false,"start_time":"2025-11-01T14:08:09.374408","status":"completed"},"tags":[]},"source":["## Pattern Detection\n","Analyze relationships between input/output grids"]},{"cell_type":"code","execution_count":3,"id":"87e628f6","metadata":{"execution":{"iopub.execute_input":"2025-11-01T14:08:09.387232Z","iopub.status.busy":"2025-11-01T14:08:09.386463Z","iopub.status.idle":"2025-11-01T14:08:09.396841Z","shell.execute_reply":"2025-11-01T14:08:09.395362Z"},"papermill":{"duration":0.016657,"end_time":"2025-11-01T14:08:09.398703","exception":false,"start_time":"2025-11-01T14:08:09.382046","status":"completed"},"tags":[]},"outputs":[{"name":"stdout","output_type":"stream","text":["âœ… PatternDetector defined\n"]}],"source":["class PatternDetector:\n","    @staticmethod\n","    def detect_color_mapping(train_examples: List[Tuple[Grid, Grid]]) -> Optional[Dict[int, int]]:\n","        \"\"\"Detect consistent color mappings across all examples\"\"\"\n","        if not train_examples:\n","            return None\n","        \n","        mapping = {}\n","        inp, out = train_examples[0]\n","        \n","        for i, row_in in enumerate(inp):\n","            for j, color_in in enumerate(row_in):\n","                if i < len(out) and j < len(out[0]):\n","                    color_out = out[i][j]\n","                    if color_in in mapping:\n","                        if mapping[color_in] != color_out:\n","                            return None\n","                    else:\n","                        mapping[color_in] = color_out\n","        \n","        for inp, out in train_examples[1:]:\n","            for i, row_in in enumerate(inp):\n","                for j, color_in in enumerate(row_in):\n","                    if i < len(out) and j < len(out[0]):\n","                        expected = mapping.get(color_in, color_in)\n","                        actual = out[i][j]\n","                        if expected != actual:\n","                            return None\n","        \n","        if all(k == v for k, v in mapping.items()):\n","            return None\n","        \n","        return mapping\n","\n","print(\"âœ… PatternDetector defined\")"]},{"cell_type":"markdown","id":"7b8149b9","metadata":{"papermill":{"duration":0.003058,"end_time":"2025-11-01T14:08:09.405947","exception":false,"start_time":"2025-11-01T14:08:09.402889","status":"completed"},"tags":[]},"source":["## Transformation Strategies\n","Each strategy checks if it applies to training examples, then applies to test"]},{"cell_type":"code","execution_count":4,"id":"5e6ea8bd","metadata":{"execution":{"iopub.execute_input":"2025-11-01T14:08:09.414523Z","iopub.status.busy":"2025-11-01T14:08:09.413756Z","iopub.status.idle":"2025-11-01T14:08:09.442405Z","shell.execute_reply":"2025-11-01T14:08:09.441316Z"},"papermill":{"duration":0.034993,"end_time":"2025-11-01T14:08:09.444185","exception":false,"start_time":"2025-11-01T14:08:09.409192","status":"completed"},"tags":[]},"outputs":[{"name":"stdout","output_type":"stream","text":["âœ… Strategies defined\n"]}],"source":["class Strategy:\n","    def __init__(self, name: str):\n","        self.name = name\n","    \n","    def can_apply(self, train_examples: List[Tuple[Grid, Grid]]) -> bool:\n","        return False\n","    \n","    def apply(self, test_input: Grid) -> Optional[Grid]:\n","        return None\n","\n","class IdentityStrategy(Strategy):\n","    def __init__(self):\n","        super().__init__(\"identity\")\n","    \n","    def can_apply(self, train_examples: List[Tuple[Grid, Grid]]) -> bool:\n","        return all(GridOps.grids_equal(inp, out) for inp, out in train_examples)\n","    \n","    def apply(self, test_input: Grid) -> Grid:\n","        return copy.deepcopy(test_input)\n","\n","class Rotate90Strategy(Strategy):\n","    def __init__(self, k: int):\n","        super().__init__(f\"rotate_{k*90}\")\n","        self.k = k\n","    \n","    def can_apply(self, train_examples: List[Tuple[Grid, Grid]]) -> bool:\n","        return all(GridOps.grids_equal(GridOps.rotate_90(inp, self.k), out)\n","                   for inp, out in train_examples)\n","    \n","    def apply(self, test_input: Grid) -> Grid:\n","        return GridOps.rotate_90(test_input, self.k)\n","\n","class FlipStrategy(Strategy):\n","    def __init__(self, direction: str):\n","        super().__init__(f\"flip_{direction}\")\n","        self.direction = direction\n","    \n","    def can_apply(self, train_examples: List[Tuple[Grid, Grid]]) -> bool:\n","        flip_fn = GridOps.flip_h if self.direction == 'h' else GridOps.flip_v\n","        return all(GridOps.grids_equal(flip_fn(inp), out) for inp, out in train_examples)\n","    \n","    def apply(self, test_input: Grid) -> Grid:\n","        return GridOps.flip_h(test_input) if self.direction == 'h' else GridOps.flip_v(test_input)\n","\n","class TransposeStrategy(Strategy):\n","    def __init__(self):\n","        super().__init__(\"transpose\")\n","    \n","    def can_apply(self, train_examples: List[Tuple[Grid, Grid]]) -> bool:\n","        return all(GridOps.grids_equal(GridOps.transpose(inp), out)\n","                   for inp, out in train_examples)\n","    \n","    def apply(self, test_input: Grid) -> Grid:\n","        return GridOps.transpose(test_input)\n","\n","class ColorMappingStrategy(Strategy):\n","    def __init__(self):\n","        super().__init__(\"color_mapping\")\n","        self.mapping = None\n","    \n","    def can_apply(self, train_examples: List[Tuple[Grid, Grid]]) -> bool:\n","        self.mapping = PatternDetector.detect_color_mapping(train_examples)\n","        if not self.mapping:\n","            return False\n","        for inp, out in train_examples:\n","            predicted = [[self.mapping.get(cell, cell) for cell in row] for row in inp]\n","            if not GridOps.grids_equal(predicted, out):\n","                return False\n","        return True\n","    \n","    def apply(self, test_input: Grid) -> Grid:\n","        if not self.mapping:\n","            return test_input\n","        return [[self.mapping.get(cell, cell) for cell in row] for row in test_input]\n","\n","class ScaleUpStrategy(Strategy):\n","    def __init__(self):\n","        super().__init__(\"scale_up\")\n","        self.factor = None\n","    \n","    def can_apply(self, train_examples: List[Tuple[Grid, Grid]]) -> bool:\n","        if not train_examples:\n","            return False\n","        inp, out = train_examples[0]\n","        h_in, w_in = GridOps.shape(inp)\n","        h_out, w_out = GridOps.shape(out)\n","        if h_in == 0 or w_in == 0:\n","            return False\n","        if h_out % h_in != 0 or w_out % w_in != 0:\n","            return False\n","        factor_h = h_out // h_in\n","        factor_w = w_out // w_in\n","        if factor_h != factor_w or factor_h == 1:\n","            return False\n","        self.factor = factor_h\n","        for inp, out in train_examples:\n","            scaled = GridOps.scale_up(inp, self.factor)\n","            if not GridOps.grids_equal(scaled, out):\n","                return False\n","        return True\n","    \n","    def apply(self, test_input: Grid) -> Grid:\n","        if not self.factor:\n","            return test_input\n","        return GridOps.scale_up(test_input, self.factor)\n","\n","class TileStrategy(Strategy):\n","    def __init__(self):\n","        super().__init__(\"tile\")\n","        self.rows = None\n","        self.cols = None\n","    \n","    def can_apply(self, train_examples: List[Tuple[Grid, Grid]]) -> bool:\n","        if not train_examples:\n","            return False\n","        inp, out = train_examples[0]\n","        h_in, w_in = GridOps.shape(inp)\n","        h_out, w_out = GridOps.shape(out)\n","        if h_in == 0 or w_in == 0:\n","            return False\n","        if h_out % h_in != 0 or w_out % w_in != 0:\n","            return False\n","        self.rows = h_out // h_in\n","        self.cols = w_out // w_in\n","        if self.rows == 1 and self.cols == 1:\n","            return False\n","        for inp, out in train_examples:\n","            tiled = GridOps.tile(inp, self.rows, self.cols)\n","            if not GridOps.grids_equal(tiled, out):\n","                return False\n","        return True\n","    \n","    def apply(self, test_input: Grid) -> Grid:\n","        if not self.rows or not self.cols:\n","            return test_input\n","        return GridOps.tile(test_input, self.rows, self.cols)\n","\n","class GravityStrategy(Strategy):\n","    def __init__(self):\n","        super().__init__(\"gravity\")\n","        self.background = 0\n","    \n","    def can_apply(self, train_examples: List[Tuple[Grid, Grid]]) -> bool:\n","        if not train_examples:\n","            return False\n","        self.background = GridOps.get_background_color(train_examples[0][0])\n","        for inp, out in train_examples:\n","            predicted = self._apply_gravity(inp)\n","            if not GridOps.grids_equal(predicted, out):\n","                return False\n","        return True\n","    \n","    def _apply_gravity(self, grid: Grid) -> Grid:\n","        h, w = GridOps.shape(grid)\n","        result = GridOps.empty_grid(h, w, self.background)\n","        for col in range(w):\n","            cells = []\n","            for row in range(h):\n","                if grid[row][col] != self.background:\n","                    cells.append(grid[row][col])\n","            start_row = h - len(cells)\n","            for i, cell in enumerate(cells):\n","                result[start_row + i][col] = cell\n","        return result\n","    \n","    def apply(self, test_input: Grid) -> Grid:\n","        return self._apply_gravity(test_input)\n","\n","class MirrorStrategy(Strategy):\n","    def __init__(self, direction: str):\n","        super().__init__(f\"mirror_{direction}\")\n","        self.direction = direction\n","    \n","    def can_apply(self, train_examples: List[Tuple[Grid, Grid]]) -> bool:\n","        for inp, out in train_examples:\n","            predicted = self._create_mirror(inp)\n","            if not GridOps.grids_equal(predicted, out):\n","                return False\n","        return True\n","    \n","    def _create_mirror(self, grid: Grid) -> Grid:\n","        if self.direction == 'h':\n","            flipped = GridOps.flip_h(grid)\n","            return [row1 + row2 for row1, row2 in zip(grid, flipped)]\n","        else:\n","            flipped = GridOps.flip_v(grid)\n","            return grid + flipped\n","    \n","    def apply(self, test_input: Grid) -> Grid:\n","        return self._create_mirror(test_input)\n","\n","print(\"âœ… Strategies defined\")"]},{"cell_type":"markdown","id":"3b6a3bc5","metadata":{"papermill":{"duration":0.003074,"end_time":"2025-11-01T14:08:09.450809","exception":false,"start_time":"2025-11-01T14:08:09.447735","status":"completed"},"tags":[]},"source":["## Main Solver\n","Orchestrates strategy selection and application"]},{"cell_type":"code","execution_count":5,"id":"a9854f7d","metadata":{"execution":{"iopub.execute_input":"2025-11-01T14:08:09.461373Z","iopub.status.busy":"2025-11-01T14:08:09.460055Z","iopub.status.idle":"2025-11-01T14:08:09.47137Z","shell.execute_reply":"2025-11-01T14:08:09.470177Z"},"papermill":{"duration":0.018658,"end_time":"2025-11-01T14:08:09.473301","exception":false,"start_time":"2025-11-01T14:08:09.454643","status":"completed"},"tags":[]},"outputs":[{"name":"stdout","output_type":"stream","text":["âœ… ARCSolver defined\n"]}],"source":["class ARCSolver:\n","    def __init__(self):\n","        self.strategies = [\n","            IdentityStrategy(),\n","            Rotate90Strategy(1),\n","            Rotate90Strategy(2),\n","            Rotate90Strategy(3),\n","            FlipStrategy('h'),\n","            FlipStrategy('v'),\n","            TransposeStrategy(),\n","            ColorMappingStrategy(),\n","            ScaleUpStrategy(),\n","            TileStrategy(),\n","            GravityStrategy(),\n","            MirrorStrategy('h'),\n","            MirrorStrategy('v'),\n","        ]\n","        self.stats = {\n","            'total': 0,\n","            'solved_by_strategy': defaultdict(int),\n","            'fallback': 0\n","        }\n","    \n","    def solve_task(self, train_examples: List[Tuple[Grid, Grid]], \n","                   test_inputs: List[Grid]) -> List[List[Grid]]:\n","        results = []\n","        for test_input in test_inputs:\n","            best_solution = None\n","            best_strategy_name = \"fallback\"\n","            \n","            for strategy in self.strategies:\n","                try:\n","                    if strategy.can_apply(train_examples):\n","                        solution = strategy.apply(test_input)\n","                        if solution is not None:\n","                            best_solution = solution\n","                            best_strategy_name = strategy.name\n","                            break\n","                except Exception:\n","                    continue\n","            \n","            if best_solution is None:\n","                best_solution = copy.deepcopy(test_input)\n","                self.stats['fallback'] += 1\n","            else:\n","                self.stats['solved_by_strategy'][best_strategy_name] += 1\n","            \n","            self.stats['total'] += 1\n","            results.append([best_solution, best_solution])\n","        \n","        return results\n","\n","print(\"âœ… ARCSolver defined\")"]},{"cell_type":"markdown","id":"54d5209a","metadata":{"papermill":{"duration":0.003483,"end_time":"2025-11-01T14:08:09.481097","exception":false,"start_time":"2025-11-01T14:08:09.477614","status":"completed"},"tags":[]},"source":["## Main Execution\n","Load data, solve tasks, generate submission"]},{"cell_type":"code","execution_count":6,"id":"c9f96755","metadata":{"execution":{"iopub.execute_input":"2025-11-01T14:08:09.490649Z","iopub.status.busy":"2025-11-01T14:08:09.489678Z","iopub.status.idle":"2025-11-01T14:08:09.717207Z","shell.execute_reply":"2025-11-01T14:08:09.715875Z"},"papermill":{"duration":0.234594,"end_time":"2025-11-01T14:08:09.719392","exception":false,"start_time":"2025-11-01T14:08:09.484798","status":"completed"},"tags":[]},"outputs":[{"name":"stdout","output_type":"stream","text":["================================================================================\n","ARC PRIZE 2025 - PRODUCTION SOLVER\n","================================================================================\n","\n","ðŸ“š Loading challenges...\n","   Found 240 tasks\n","\n","ðŸ”§ Initialized 13 strategies\n","\n","ðŸš€ Solving tasks...\n","   Progress: 20/240\n","   Progress: 40/240\n","   Progress: 60/240\n","   Progress: 80/240\n","   Progress: 100/240\n","   Progress: 120/240\n","   Progress: 140/240\n","   Progress: 160/240\n","   Progress: 180/240\n","   Progress: 200/240\n","   Progress: 220/240\n","   Progress: 240/240\n","   Complete: 240/240\n","\n","ðŸ’¾ Saving submission...\n","\n","================================================================================\n","STATISTICS\n","================================================================================\n","Total test inputs: 259\n","Fallback (input copied): 257\n","\n","Strategies used:\n","  gravity: 1\n","  rotate_180: 1\n","\n","================================================================================\n","âœ… COMPLETE!\n","   File: /kaggle/working/submission.json\n","================================================================================\n"]}],"source":["print(\"=\"*80)\n","print(\"ARC PRIZE 2025 - PRODUCTION SOLVER\")\n","print(\"=\"*80)\n","\n","# Paths\n","CHALLENGES_PATH = '/kaggle/input/arc-prize-2025/arc-agi_test_challenges.json'\n","OUTPUT_PATH = '/kaggle/working/submission.json'\n","\n","# Load challenges\n","print(f\"\\nðŸ“š Loading challenges...\")\n","with open(CHALLENGES_PATH, 'r') as f:\n","    challenges = json.load(f)\n","print(f\"   Found {len(challenges)} tasks\")\n","\n","# Initialize solver\n","solver = ARCSolver()\n","print(f\"\\nðŸ”§ Initialized {len(solver.strategies)} strategies\")\n","\n","# Solve all tasks\n","print(\"\\nðŸš€ Solving tasks...\")\n","submission = {}\n","\n","for i, (task_id, task_data) in enumerate(challenges.items()):\n","    if (i + 1) % 20 == 0:\n","        print(f\"   Progress: {i+1}/{len(challenges)}\")\n","    \n","    train_examples = [(ex['input'], ex['output']) for ex in task_data['train']]\n","    test_inputs = [ex['input'] for ex in task_data['test']]\n","    \n","    predictions = solver.solve_task(train_examples, test_inputs)\n","    submission[task_id] = predictions\n","\n","print(f\"   Complete: {len(challenges)}/{len(challenges)}\")\n","\n","# Save submission\n","print(f\"\\nðŸ’¾ Saving submission...\")\n","with open(OUTPUT_PATH, 'w') as f:\n","    json.dump(submission, f)\n","\n","# Print statistics\n","print(\"\\n\" + \"=\"*80)\n","print(\"STATISTICS\")\n","print(\"=\"*80)\n","print(f\"Total test inputs: {solver.stats['total']}\")\n","print(f\"Fallback (input copied): {solver.stats['fallback']}\")\n","print(f\"\\nStrategies used:\")\n","for strategy, count in sorted(solver.stats['solved_by_strategy'].items(), \n","                             key=lambda x: x[1], reverse=True):\n","    print(f\"  {strategy}: {count}\")\n","\n","print(\"\\n\" + \"=\"*80)\n","print(\"âœ… COMPLETE!\")\n","print(f\"   File: {OUTPUT_PATH}\")\n","print(\"=\"*80)"]}],"metadata":{"kaggle":{"accelerator":"none","dataSources":[{"databundleVersionId":11802066,"sourceId":91496,"sourceType":"competition"}],"dockerImageVersionId":31154,"isGpuEnabled":false,"isInternetEnabled":false,"language":"python","sourceType":"notebook"},"kernelspec":{"display_name":"Python 3","language":"python","name":"python3"},"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.11.13"},"papermill":{"default_parameters":{},"duration":5.88442,"end_time":"2025-11-01T14:08:10.144619","environment_variables":{},"exception":null,"input_path":"__notebook__.ipynb","output_path":"__notebook__.ipynb","parameters":{},"start_time":"2025-11-01T14:08:04.260199","version":"2.6.0"}},"nbformat":4,"nbformat_minor":5}