#!/usr/bin/env python3
"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   ARC DATASET SQL INJECTION EXPLOIT                           â•‘
â•‘                                                                               â•‘
â•‘  Treat JSON files like a vulnerable SQL database                              â•‘
â•‘  Use "injection" techniques to reveal hidden answers                          â•‘
â•‘  (Educational: Shows why data isolation matters!)                             â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""

import json
import numpy as np
from pathlib import Path
from typing import Dict, List, Any, Optional

# =============== THE "VULNERABLE" SYSTEM ===============

class VulnerableARCDataLoader:
    """
    A poorly designed data loader that doesn't properly isolate
    training challenges from solutions
    
    (This is intentionally bad - shows why security matters!)
    """
    
    def __init__(self, data_dir: str = "/mnt/user-data/uploads"):
        self.data_dir = Path(data_dir)
        
        # Load everything into memory (bad practice!)
        self.training_challenges = self._load_json("arc-agi_training_challenges.json")
        self.training_solutions = self._load_json("arc-agi_training_solutions.json")
        self.evaluation_challenges = self._load_json("arc-agi_evaluation_challenges.json")
        self.evaluation_solutions = self._load_json("arc-agi_evaluation_solutions.json")
        self.test_challenges = self._load_json("arc-agi_test_challenges.json")
        # Note: test_solutions don't exist (that's the whole challenge!)
    
    def _load_json(self, filename: str) -> Dict:
        """Load JSON file"""
        try:
            with open(self.data_dir / filename) as f:
                return json.load(f)
        except:
            return {}
    
    def get_challenge(self, task_id: str, split: str = "training") -> Dict:
        """
        VULNERABLE: Doesn't validate input properly!
        Could be exploited with "injection"
        """
        # Select dataset based on split
        if split == "training":
            data = self.training_challenges
        elif split == "evaluation":
            data = self.evaluation_challenges
        elif split == "test":
            data = self.test_challenges
        else:
            data = {}
        
        # VULNERABILITY: Direct key access without sanitization
        return data.get(task_id, {})
    
    def get_solution(self, task_id: str, split: str = "training") -> List:
        """
        VULNERABLE: Returns solutions without proper access control!
        """
        if split == "training":
            data = self.training_solutions
        elif split == "evaluation":
            data = self.evaluation_solutions
        else:
            # Test solutions shouldn't be accessible!
            return None
        
        # VULNERABILITY: No authentication/authorization check
        return data.get(task_id, [])


# =============== SQL INJECTION STYLE EXPLOITS ===============

class ARCDataInjector:
    """
    Various "injection" attacks on the ARC dataset
    Treats JSON structure like SQL database
    """
    
    def __init__(self, vulnerable_loader: VulnerableARCDataLoader):
        self.loader = vulnerable_loader
    
    def exploit_1_union_injection(self, task_id: str) -> Dict[str, Any]:
        """
        SQL Injection: UNION attack
        
        SQL equivalent:
          SELECT * FROM challenges WHERE id='xyz' UNION SELECT * FROM solutions;
        
        JSON equivalent:
          Access both challenges AND solutions in single query
        """
        print("\n[EXPLOIT 1] UNION Injection - Merge Challenges + Solutions")
        print("-" * 80)
        
        # Get challenge
        challenge = self.loader.get_challenge(task_id, "training")
        print(f"Challenge for {task_id}:")
        print(f"  Train examples: {len(challenge.get('train', []))}")
        print(f"  Test examples: {len(challenge.get('test', []))}")
        
        # EXPLOIT: Also grab solution (shouldn't be available in real competition!)
        solution = self.loader.get_solution(task_id, "training")
        print(f"\nðŸ’€ EXPLOITED - Retrieved solution:")
        print(f"  Test answers: {len(solution)}")
        
        # Merge them (UNION)
        exploited_data = {
            'challenge': challenge,
            'solution': solution,  # ðŸš¨ DATA LEAK!
            'exploited': True
        }
        
        return exploited_data
    
    def exploit_2_boolean_injection(self, task_id: str) -> bool:
        """
        SQL Injection: Boolean-based blind
        
        SQL equivalent:
          SELECT * FROM solutions WHERE id='xyz' AND 1=1;  -- True
          SELECT * FROM solutions WHERE id='xyz' AND 1=0;  -- False
        
        JSON equivalent:
          Infer solution by checking existence
        """
        print("\n[EXPLOIT 2] Boolean Injection - Infer Solution Existence")
        print("-" * 80)
        
        # Try to access solution
        solution = self.loader.get_solution(task_id, "training")
        
        if solution is not None and len(solution) > 0:
            print(f"âœ“ Solution exists for {task_id}")
            print(f"  Inferred: {len(solution)} test cases have answers")
            return True
        else:
            print(f"âœ— No solution for {task_id}")
            return False
    
    def exploit_3_time_based_injection(self, task_ids: List[str]) -> Dict[str, float]:
        """
        SQL Injection: Time-based blind
        
        SQL equivalent:
          SELECT * FROM solutions WHERE id='xyz'; WAITFOR DELAY '00:00:05';
        
        JSON equivalent:
          Time how long it takes to access solutions vs challenges
          (Solutions might be on slower storage, revealing their existence)
        """
        print("\n[EXPLOIT 3] Time-Based Injection - Timing Attack")
        print("-" * 80)
        
        import time
        
        timing_results = {}
        
        for task_id in task_ids[:5]:  # Test first 5
            # Time challenge access
            start = time.time()
            challenge = self.loader.get_challenge(task_id, "training")
            challenge_time = time.time() - start
            
            # Time solution access
            start = time.time()
            solution = self.loader.get_solution(task_id, "training")
            solution_time = time.time() - start
            
            timing_results[task_id] = {
                'challenge_time': challenge_time,
                'solution_time': solution_time,
                'ratio': solution_time / (challenge_time + 1e-10)
            }
            
            print(f"{task_id}:")
            print(f"  Challenge: {challenge_time*1000:.2f}ms")
            print(f"  Solution:  {solution_time*1000:.2f}ms")
        
        return timing_results
    
    def exploit_4_path_traversal(self) -> Dict[str, Any]:
        """
        Path Traversal: Access files outside intended scope
        
        Like: ../../../../etc/passwd
        
        JSON equivalent:
          Try to access test solutions (shouldn't exist!)
        """
        print("\n[EXPLOIT 4] Path Traversal - Access Forbidden Files")
        print("-" * 80)
        
        # Try to access test solutions
        print("Attempting to access test_solutions.json...")
        
        try:
            test_solutions_path = self.loader.data_dir / "arc-agi_test_solutions.json"
            
            if test_solutions_path.exists():
                with open(test_solutions_path) as f:
                    test_solutions = json.load(f)
                
                print(f"ðŸš¨ CRITICAL EXPLOIT: Test solutions found!")
                print(f"   {len(test_solutions)} test answers leaked!")
                return test_solutions
            else:
                print(f"âœ“ Test solutions not found (as expected)")
                print(f"   Competition integrity maintained")
                return {}
        except Exception as e:
            print(f"âœ“ Access denied: {e}")
            return {}
    
    def exploit_5_direct_object_reference(self, split: str = "evaluation") -> Dict[str, Any]:
        """
        IDOR: Direct Object Reference
        
        Access evaluation solutions by directly referencing them
        (In real competition, evaluation solutions are hidden during test)
        """
        print("\n[EXPLOIT 5] IDOR - Direct Object Reference")
        print("-" * 80)
        
        print(f"Attempting to access {split} solutions directly...")
        
        if split == "evaluation":
            # This SHOULD be protected during competition
            solutions = self.loader.evaluation_solutions
            
            if solutions:
                print(f"ðŸš¨ EXPLOIT SUCCESS: Evaluation solutions leaked!")
                print(f"   {len(solutions)} tasks compromised")
                
                # Show first example
                task_id = list(solutions.keys())[0]
                print(f"\n   Example - {task_id}:")
                print(f"   Solution shape: {np.array(solutions[task_id][0]).shape}")
                
                return solutions
            else:
                print(f"âœ“ No solutions found")
        
        return {}


# =============== THE ACTUAL "INJECTION" ===============

def sql_inject_the_answers():
    """
    The main exploit: Extract all available answers
    using SQL injection style techniques
    """
    print("="*80)
    print("ARC DATASET SQL INJECTION EXPLOIT")
    print("Treating JSON as vulnerable SQL database")
    print("="*80)
    
    # Load vulnerable system
    loader = VulnerableARCDataLoader()
    injector = ARCDataInjector(loader)
    
    # Get some task IDs to exploit
    training_task_ids = list(loader.training_challenges.keys())[:10]
    
    # Exploit 1: UNION injection (merge challenges + solutions)
    task_id = training_task_ids[0]
    exploited = injector.exploit_1_union_injection(task_id)
    
    if exploited['solution']:
        print(f"\nðŸŽ¯ LEAKED ANSWER:")
        print(f"   Input shape: {np.array(exploited['challenge']['test'][0]['input']).shape}")
        print(f"   Output shape: {np.array(exploited['solution'][0]).shape}")
        print(f"   Output preview: {np.array(exploited['solution'][0])}")
    
    # Exploit 2: Boolean injection
    injector.exploit_2_boolean_injection(task_id)
    
    # Exploit 3: Timing attack
    injector.exploit_3_time_based_injection(training_task_ids)
    
    # Exploit 4: Path traversal (test solutions)
    test_leaks = injector.exploit_4_path_traversal()
    
    # Exploit 5: IDOR (evaluation solutions)
    eval_leaks = injector.exploit_5_direct_object_reference("evaluation")
    
    # Summary
    print("\n" + "="*80)
    print("EXPLOIT SUMMARY")
    print("="*80)
    
    print(f"\nâœ“ Training solutions: {len(loader.training_solutions)} (accessible)")
    print(f"âœ“ Evaluation solutions: {len(loader.evaluation_solutions)} (accessible)")
    print(f"âœ— Test solutions: 0 (not provided - competition integrity intact)")
    
    print("\nðŸŽ“ LESSONS:")
    print("  1. Training data needs solutions (for learning)")
    print("  2. Evaluation data CAN have solutions (for validation)")
    print("  3. Test data MUST NOT have solutions (for fair competition)")
    print("  4. In real competition, eval solutions hidden until after deadline")
    
    print("\nðŸ”’ PROPER SECURITY:")
    print("  1. Separate train/eval/test data access")
    print("  2. Time-lock evaluation solutions")
    print("  3. Never include test solutions in dataset")
    print("  4. Validate all data access requests")
    
    return {
        'training_leaked': len(loader.training_solutions),
        'evaluation_leaked': len(loader.evaluation_solutions),
        'test_leaked': len(test_leaks),
    }


# =============== THE "PROPER" WAY ===============

class SecureARCDataLoader:
    """
    How to PROPERLY handle ARC data without vulnerabilities
    """
    
    def __init__(self, data_dir: str, mode: str = "training"):
        self.data_dir = Path(data_dir)
        self.mode = mode  # training, evaluation, or test
        
        # Only load what's needed for current mode
        if mode == "training":
            self.challenges = self._load_json("arc-agi_training_challenges.json")
            self.solutions = self._load_json("arc-agi_training_solutions.json")
        elif mode == "evaluation":
            self.challenges = self._load_json("arc-agi_evaluation_challenges.json")
            # Solutions time-locked until after submission
            self.solutions = {}
        elif mode == "test":
            self.challenges = self._load_json("arc-agi_test_challenges.json")
            # Solutions NEVER provided
            self.solutions = {}
    
    def _load_json(self, filename: str) -> Dict:
        filepath = self.data_dir / filename
        if not filepath.exists():
            raise FileNotFoundError(f"Required file not found: {filename}")
        with open(filepath) as f:
            return json.load(f)
    
    def get_challenge(self, task_id: str) -> Dict:
        """Get challenge with proper access control"""
        if task_id not in self.challenges:
            raise ValueError(f"Task {task_id} not found in {self.mode} set")
        return self.challenges[task_id]
    
    def get_solution(self, task_id: str) -> Optional[List]:
        """
        Get solution with proper authorization
        Only available in training mode!
        """
        if self.mode != "training":
            raise PermissionError(f"Solutions not accessible in {self.mode} mode")
        
        if task_id not in self.solutions:
            raise ValueError(f"Solution for {task_id} not found")
        
        return self.solutions[task_id]


# =============== TESTING ===============

if __name__ == "__main__":
    # Run the "exploit"
    results = sql_inject_the_answers()
    
    # Show that proper security works
    print("\n" + "="*80)
    print("PROPER SECURITY IMPLEMENTATION")
    print("="*80)
    
    print("\n[TEST] Secure loader in test mode")
    secure = SecureARCDataLoader("/mnt/user-data/uploads", mode="test")
    
    task_ids = list(secure.challenges.keys())[:3]
    for task_id in task_ids:
        challenge = secure.get_challenge(task_id)
        print(f"\nâœ“ Retrieved challenge {task_id}")
        print(f"  Train examples: {len(challenge['train'])}")
        print(f"  Test examples: {len(challenge['test'])}")
        
        # Try to access solution (should fail!)
        try:
            solution = secure.get_solution(task_id)
            print(f"  ðŸš¨ SECURITY BREACH: Got solution!")
        except PermissionError as e:
            print(f"  âœ“ Solution access blocked: {e}")
    
    print("\n" + "="*80)
    print("INJECTION COMPLETE! (But test answers remain secure)")
    print("="*80)
